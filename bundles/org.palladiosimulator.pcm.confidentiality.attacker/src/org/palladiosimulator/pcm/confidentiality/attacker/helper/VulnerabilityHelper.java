package org.palladiosimulator.pcm.confidentiality.attacker.helper;

public final class VulnerabilityHelper {
    private VulnerabilityHelper() {
        assert false;
    }

//    /**
//     * Checks whether an attack is possible and returns the {@link Vulnerability} with the highest
//     * impact on Confidentiality. If the vulnerabilities contain multiple vulnerabilities with
//     * highest impact it returns any vulnerbility of it
//     *
//     * @param credentials
//     * @param policies
//     * @param vulnerabilities
//     * @param attacks
//     * @param vector
//     * @return {@link Vulnerability} with the highest ConfidentialityImpact if no attack is possible
//     *         null
//     */
//    public static Vulnerability checkAttack(final ContextSet credentials, List<ContextSet> policies,
//            final List<Vulnerability> vulnerabilities, final List<Attack> attacks, final AttackVector vector) {
//        final var applicableVulnerabilities = new ArrayList<Vulnerability>();
//        if (policies == null) {
//            policies = new ArrayList<>();
//        }
//        if (policies.isEmpty()) {
//            final var emptySet = SetFactory.eINSTANCE.createContextSet();
//            policies.add(emptySet);
//        }
//        for (final var vulnerability : vulnerabilities) {
//            for (final var attack : attacks) {
//                for (final var policy : policies) {
//                    if (attack.canExploit(vulnerability, credentials, policy, vector)) {
//                        if (vulnerability.getConfidentialityImpact() == ConfidentialityImpact.HIGH) {
//                            return vulnerability;
//                        }
//                        applicableVulnerabilities.add(vulnerability);
//                    }
//                }
//            }
//        }
//        final var returnValue = applicableVulnerabilities.stream()
//                .filter(e -> e.getConfidentialityImpact() == ConfidentialityImpact.LOW).findAny();
//        if (returnValue.isPresent()) {
//            return returnValue.get();
//        }
//        return applicableVulnerabilities.stream().findAny().orElse(null);
//    }
//
//    public static List<Vulnerability> getVulnerabilities(
//            final VulnerabilitySystemSpecification vulnerabilityspecification, final ResourceContainer resource) {
//        return getVulnerabilities(vulnerabilityspecification.getVulnerabilities(), resource);
//    }
//
//    public static List<Vulnerability> getVulnerabilities(final List<SystemIntegration> vulnerabilitySpecification,
//            final ResourceContainer resource) {
//        return getVulnerbilities(vulnerabilitySpecification, SystemIntegration::getResourcecontainer, resource);
//    }
//
//    public static List<Vulnerability> getVulnerabilities(
//            final VulnerabilitySystemSpecification vulnerabilityspecification, final AssemblyContext component) {
//        return getVulnerabilities(vulnerabilityspecification.getVulnerabilities(), component);
//    }
//
//    public static List<Vulnerability> getVulnerabilities(
//            final VulnerabilitySystemSpecification vulnerabilityspecification,
//            final MethodSpecification methodSpecification) {
//        return getVulnerabilities(vulnerabilityspecification.getVulnerabilities(), methodSpecification);
//    }
//
//    public static List<Vulnerability> getVulnerabilities(final List<SystemIntegration> vulnerabilitySpecification,
//            final MethodSpecification methodSpecification) {
//        return getVulnerbilities(vulnerabilitySpecification, SystemIntegration::getMethodspecification,
//                methodSpecification);
//    }
//
//    public static List<Vulnerability> getVulnerabilities(final List<SystemIntegration> vulnerabilitySpecification,
//            final AssemblyContext component) {
//        return getVulnerbilities(vulnerabilitySpecification, SystemIntegration::getAssemblycontext, component);
//    }
//
//    public static List<Vulnerability> getVulnerabilities(
//            final VulnerabilitySystemSpecification vulnerabilityspecification, final LinkingResource resource) {
//        return getVulnerabilities(vulnerabilityspecification.getVulnerabilities(), resource);
//    }
//
//    public static List<Vulnerability> getVulnerabilities(final List<SystemIntegration> vulnerabilitySpecification,
//            final LinkingResource resource) {
//        return getVulnerbilities(vulnerabilitySpecification, SystemIntegration::getLinkingresource, resource);
//    }
//
//    private static List<Vulnerability> getVulnerbilities(final List<SystemIntegration> specification,
//            final Function<SystemIntegration, EObject> method, final EObject object) {
//        return specification.stream().filter(e -> EcoreUtil.equals(method.apply(e), object))
//                .map(SystemIntegration::getVulnerability).collect(Collectors.toList());
//    }

}
