package org.palladiosimulator.pcm.confidentiality.attacker.helper;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.VulnerabilitySystemSpecification;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Attack;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.ConfidentialityImpact;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Vulnerability;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.SystemIntegration;
import org.palladiosimulator.pcm.confidentiality.context.set.ContextSet;
import org.palladiosimulator.pcm.confidentiality.context.set.SetFactory;
import org.palladiosimulator.pcm.confidentiality.context.specification.assembly.MethodSpecification;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.resourceenvironment.LinkingResource;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;

public final class VulnerabilityHelper {
    private VulnerabilityHelper() {
        assert false;
    }

    /**
     * Checks whether an attack is possible and returns the {@link Vulnerability} with the highest
     * impact on Confidentiality. If the vulnerabilities contain multiple vulnerabilities with
     * highest impact it returns any vulnerbility of it
     *
     * @param credentials
     * @param policies
     * @param vulnerabilities
     * @param attacks
     * @param vector
     * @return {@link Vulnerability} with the highest ConfidentialityImpact if no attack is possible
     *         null
     */
    public static Vulnerability checkAttack(final ContextSet credentials, List<ContextSet> policies,
            final List<Vulnerability> vulnerabilities, final List<Attack> attacks, final AttackVector vector) {
        final var applicableVulnerabilities = new ArrayList<Vulnerability>();
        if (policies == null) {
            policies = new ArrayList<>();
        }
        if (policies.isEmpty()) {
            final var emptySet = SetFactory.eINSTANCE.createContextSet();
            policies.add(emptySet);
        }
        for (final var vulnerability : vulnerabilities) {
            for (final var attack : attacks) {
                for (final var policy : policies) {
                    if (attack.canExploit(vulnerability, credentials, policy, vector)) {
                        if (vulnerability.getConfidentialityImpact() == ConfidentialityImpact.HIGH) {
                            return vulnerability;
                        }
                        applicableVulnerabilities.add(vulnerability);
                    }
                }
            }
        }
        final var returnValue = applicableVulnerabilities.stream()
                .filter(e -> e.getConfidentialityImpact() == ConfidentialityImpact.LOW).findAny();
        if (returnValue.isPresent()) {
            return returnValue.get();
        }
        return applicableVulnerabilities.stream().findAny().orElse(null);
    }

    public static List<Vulnerability> getVulnerabilities(
            final VulnerabilitySystemSpecification vulnerabilityspecification, final ResourceContainer resource) {
        return getVulnerabilities(vulnerabilityspecification.getVulnerabilities(), resource);
    }

    public static List<Vulnerability> getVulnerabilities(final List<SystemIntegration> vulnerabilitySpecification,
            final ResourceContainer resource) {
        return getVulnerbilities(vulnerabilitySpecification, SystemIntegration::getResourcecontainer, resource);
    }

    public static List<Vulnerability> getVulnerabilities(
            final VulnerabilitySystemSpecification vulnerabilityspecification, final AssemblyContext component) {
        return getVulnerabilities(vulnerabilityspecification.getVulnerabilities(), component);
    }

    public static List<Vulnerability> getVulnerabilities(
            final VulnerabilitySystemSpecification vulnerabilityspecification,
            final MethodSpecification methodSpecification) {
        return getVulnerabilities(vulnerabilityspecification.getVulnerabilities(), methodSpecification);
    }

    public static List<Vulnerability> getVulnerabilities(final List<SystemIntegration> vulnerabilitySpecification,
            final MethodSpecification methodSpecification) {
        return getVulnerbilities(vulnerabilitySpecification, SystemIntegration::getMethodspecification,
                methodSpecification);
    }

    public static List<Vulnerability> getVulnerabilities(final List<SystemIntegration> vulnerabilitySpecification,
            final AssemblyContext component) {
        return getVulnerbilities(vulnerabilitySpecification, SystemIntegration::getAssemblycontext, component);
    }

    public static List<Vulnerability> getVulnerabilities(
            final VulnerabilitySystemSpecification vulnerabilityspecification, final LinkingResource resource) {
        return getVulnerabilities(vulnerabilityspecification.getVulnerabilities(), resource);
    }

    public static List<Vulnerability> getVulnerabilities(final List<SystemIntegration> vulnerabilitySpecification,
            final LinkingResource resource) {
        return getVulnerbilities(vulnerabilitySpecification, SystemIntegration::getLinkingresource, resource);
    }

    private static List<Vulnerability> getVulnerbilities(final List<SystemIntegration> specification,
            final Function<SystemIntegration, EObject> method, final EObject object) {
        return specification.stream().filter(e -> EcoreUtil.equals(method.apply(e), object))
                .map(SystemIntegration::getVulnerability).collect(Collectors.toList());
    }

}
