package org.palladiosimulator.pcm.confidentiality.attacker.helper;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.AttackerSystemSpecificationContainer;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Attack;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.ConfidentialityImpact;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Role;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Vulnerability;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.MethodSpecification;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.core.entity.Entity;
import org.palladiosimulator.pcm.repository.BasicComponent;
import org.palladiosimulator.pcm.resourceenvironment.LinkingResource;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;

public final class VulnerabilityHelper {
    private VulnerabilityHelper() {
        assert false;
    }

    /**
     * Checks whether an attack is possible and returns the {@link Vulnerability} with the highest
     * impact on Confidentiality. If the vulnerabilities contain multiple vulnerabilities with
     * highest impact it returns any vulnerability of it
     *
     * @param credentials
     * @param policies
     * @param vulnerabilities
     * @param attacks
     * @param vector
     * @return {@link Vulnerability} with the highest ConfidentialityImpact if no attack is possible
     *         null
     */
    public static Vulnerability checkAttack(boolean authenticated, final List<Vulnerability> vulnerabilities,
            final List<Attack> attacks, final AttackVector vector, EList<Role> roles) {
        final var applicableVulnerabilities = new ArrayList<Vulnerability>();
        for (final var vulnerability : vulnerabilities) {
            for (final var attack : attacks) {

                if (attack.canExploit(vulnerability, authenticated, vector, roles)) {
                    if (vulnerability.getConfidentialityImpact() == ConfidentialityImpact.HIGH) {
                        return vulnerability;
                    }
                    applicableVulnerabilities.add(vulnerability);
                }

            }

        }
        final var returnValue = applicableVulnerabilities.stream()
                .filter(e -> e.getConfidentialityImpact() == ConfidentialityImpact.LOW).findAny();
        if (returnValue.isPresent()) {
            return returnValue.get();
        }
        return applicableVulnerabilities.stream().findAny().orElse(null);
    }

    public static EList<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification, final ResourceContainer resource) {

        return Optional.ofNullable(vulnerabilityspecification.getResourceVulnerabilities().get(resource))
                .orElse(new BasicEList<>());
    }

    public static EList<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification, final LinkingResource resource) {
        return Optional.ofNullable(vulnerabilityspecification.getLinkingVulnerabilities().get(resource))
                .orElse(new BasicEList<>());
    }

    public static EList<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification, final AssemblyContext resource) {
        return Optional.ofNullable(vulnerabilityspecification.getAssemblyVulnerabilities().get(resource))
                .orElse(new BasicEList<>());
    }

    public static EList<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification, final MethodSpecification resource) {
        return Optional.ofNullable(vulnerabilityspecification.getMethodVulnerabilities().get(resource))
                .orElse(new BasicEList<>());
    }

    public static EList<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification, final BasicComponent resource) {
        return Optional.ofNullable(vulnerabilityspecification.getComponentVulnerabilities().get(resource))
                .orElse(new BasicEList<>());
    }

    public static EList<Role> getRoles(final AttackerSystemSpecificationContainer vulnerabilityspecification,
            List<Entity> hackedEntities) {
        // Search for roles of hacked entity and returns them
        return hackedEntities.stream().flatMap(
                entity -> Optional.ofNullable(vulnerabilityspecification.getRoles().get(entity))
                        .orElse(new BasicEList<>()).stream())
                .collect(Collectors.toCollection(BasicEList::new));

    }


}
